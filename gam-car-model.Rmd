---
title: "GAM and CAR"
author: "Xinye Li"
date: "12/12/2018"
output: html_document
---

##Please run Ruthe's "california-air-health" first!


```{r message = FALSE, warning=FALSE}
# prepare data
library("SpatioTemporal"); library("sp")

#1. latitude and longitude
loc = cali@data[,c(5,6,ncol(cali@data)-1,ncol(cali@data))]
loc$NAME = as.character(loc$NAME)
names(loc)[1] = "county"
loc$NAMELSAD = as.character(loc$NAMELSAD)

#2. xy coordinates using WGS84, just in case
# source: https://rpubs.com/dasaptaerwin/19879
xy <- as.data.frame(loc[,c(3,4)])
xy <- as.data.frame(apply(xy,2,function(x){as.numeric(as.character(x))}))
cord.dec = SpatialPoints(cbind(xy$INTPTLON,-xy$INTPTLAT), 
                         proj4string=CRS("+proj=longlat"))
coord <- as.data.frame(spTransform(cord.dec, CRS("+init=epsg:32748")))

#3. combine latlong and coordinates
loc.all <- data.frame(loc,x = coord$coords.x1, y = coord$coords.x2)


#4. merge; convert lat and long to numeric 
# this is the data used for GAM, but not for CAR model

datnew <- left_join(dat,loc.all,by = "county") %>% 
  mutate(lat = as.numeric(as.character(INTPTLAT)),
         long = as.numeric(as.character(INTPTLON))) 


```



##GAM: test whether the trend is linear

** 1. PM2.5 ** 
-Non-linear spatial and temporal trends detected for PM 2.5 (from pvalue in "Approximate significance of smooth terms")



```{r message = FALSE,warning = FALSE}
# EDA: temporal trend in each county
plot_time <- datnew %>% group_by(year, county) %>% filter(!is.na(pm25)) %>%
  ggplot(aes(x = year, y = pm25)) +
  geom_smooth(method = "gam",formula = y~s(x,k = 5)) +
  facet_wrap(.~county,scales="free_y") +
  theme_bw()


# load mgcv package. We will be using "gam" function
library("mgcv")

# test the spatio-temporal trend of PM2.5
gam_pm25_spacetime <- gam(pm25~s(lat,long) + s(year, k = 5),
                          data = datnew,family = gaussian)
summary.gam(gam_pm25_spacetime)$s.table


```

**2. Outcomes**
```{r}
# test the spatio-temporal trend of outcome: wittern as a function
# default data set: "datnew"; input an outcome, y is a character

st.trend <- function(y,data = datnew) {
  require("mgcv");require("dplyr")
  # check whether input outcome exists
  if (! y %in% names(datnew)[8:24]) 
  {print("Outcome does not exist")}
  
  else{
    y = datnew[,y]
  #GAM
  gam_outcome_spacetime <- gam(y~s(lat,long)+s(year, k = 5),
                               data = datnew,family = gaussian)
  test_linear_trend <- summary(gam_outcome_spacetime)$s.table
  

  #return smoothness results
  return(test_linear_trend)}
  
}

# test
st.trend("pq_acute")
st.trend("ds")
```


##CAR model 
**1. Spatial autocorrelation: Moran's I index**
-PM2.5: Spatially autocorrelated
-Outcomes: All but Angina and Perforated Appendix are spatially autocorrelated


```{r}
library("ape")
#0. test the existence of spatial auto-correlation: Moran's I
ca.dists <- as.matrix(dist(cbind(datnew$long, datnew$lat)))
ca.dists.inv <- 1/ca.dists
diag(ca.dists.inv) <- 0
ca.dists.inv[is.infinite(ca.dists.inv)] <- 0

moransI_pval <- c()
for (i in 1:17){
  moransI_pval[i] <- Moran.I(data.frame(datnew)[,7+i],
                             ca.dists.inv,na.rm = TRUE)$p.value 
}

# most of the outcomes are spatially autocorrelated except for 
names(datnew)[c(8:24)][which(moransI_pval > .05)]

#pm25
Moran.I(data.frame(datnew)[,"pm25"],ca.dists.inv,na.rm = TRUE)$p.value 
```

**2. CAR model**
The conditional autoregressive (CAR) model accounts for the autocorrelation from space and time, then models the residuals and gives overall estimates (not county-specific) for predictors of interest.

```{r message=FALSE,warning=FALSE}
#0. load library
library("spdep"); library("CARBayesST")
#1. prepare data for CAR model: need to delete counties with NAs in pm25
dat_car <- datnew %>% filter(!county %in% c("Yuba","El Dorado"))

#2. W matrix with binary elements that indicate shared border between counties
W.nb <-poly2nb(cali)
W.list <- nb2listw(W.nb, style = "B")
W <- nb2mat(W.nb, style = "B")
rownames(W) = cali@data$NAME;colnames(W) = cali@data$NAME

# we have limited counties
index = c(which(is.na(match(loc.all$county,dat_car$county))))
W <- W[-index,-index]

# Shasta d.n. have any neighbor -> manually inpute the closet neighbor as 1
# make sure W is symmetric
W[12,28] <- 1; W[28,12] <- 1;W[12,14] <- 1;W[14,12] <- 1

#3. Impute missing covariate 
dat_car[which(is.na(dat_car$pm25)),c("pm25")] <- c(1,0,0,1.61,10,1,0,1,1,1,0,0,.5,.5,3.5,4,1)

#4. CAR model

# the function "car.model" takes an outcome name (character) and return the summary that includes coefficient estimate and credible interval

# default data: dat_car
car.model <- function(y,data = dat_car){
  require("knitr");require("CARBayes");require("dplyr")
  if (! y %in% names(dat_car)[8:24]) 
  {print("Outcome does not exist")}
  else{
    y2 = pull(dat_car[,y])
    
    dat_car_copy <- data.frame(dat_car) %>% 
      mutate(outcome_interest = y2) %>%
      dplyr::select(outcome_interest,year,age60_perc,est.black.percent,
             bachelor_perc,pm25)
    
    fitst_adapt <- ST.CARadaptive(outcome_interest~age60_perc + 
                                    est.black.percent +
                                    bachelor_perc + year +pm25, 
                                  family = "gaussian",
                                  data = dat_car_copy, W = W, burnin = 500, 
                                  n.sample = 50500,
                                  thin = 10)
    #fitst_adapt$summary.results[c(2:5),c(1,2,3)]
    
    point_estimate <- unname(round(fitst_adapt$summary.results[c(2:4),1],2))
    lb <- round(fitst_adapt$summary.results[c(2:4),2],2)
    ub <- round(fitst_adapt$summary.results[c(2:4),3],2)
    CI <- noquote(paste("(",lb,",",ub,")",sep = ""))
    var_name <- c("Age>60 (%)", "Black (%)", ">Bachelor (%)")
    model_summary <- cbind(var_name, point_estimate, CI)
    colnames(model_summary) <- c("","Estimate","95% Credible Interval")
    tb <- kable(model_summary)
    return(tb)
  }
}

car.model("diabetes_lt")


```


